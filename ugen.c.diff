--- ugen.c.orig	Wed Jun  3 14:35:32 2015
+++ ugen.c	Sun Jul  5 22:10:06 2015
@@ -46,9 +46,13 @@
 #include <sys/vnode.h>
 #include <sys/poll.h>
 
+#include <machine/bus.h>
+
 #include <dev/usb/usb.h>
 #include <dev/usb/usbdi.h>
 #include <dev/usb/usbdi_util.h>
+#include <dev/usb/usbdivar.h>
+#include <dev/usb/usb_mem.h>
 #include <dev/usb/usbdevs.h>
 
 #ifdef UGEN_DEBUG
@@ -104,6 +108,8 @@
 	u_char sc_secondary;
 };
 
+void ugen_request_async_callback(struct usbd_xfer *, void *, usbd_status);
+
 void ugenintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
 void ugen_isoc_rintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
 int ugen_do_read(struct ugen_softc *, int, struct uio *, int);
@@ -130,6 +136,36 @@
 	sizeof(struct ugen_softc), ugen_match, ugen_attach, ugen_detach
 };
 
+TAILQ_HEAD(, ctl_urb) urb_entry_head;
+TAILQ_HEAD(, ctl_urb) endpt_head;
+
+void ugen_request_async_callback(struct usbd_xfer *xfer, void *priv, usbd_status s) {
+	struct ctl_urb *urb = priv;
+	struct ugen_endpoint *sce = (struct ugen_endpoint *)urb->sce;
+
+	urb->status = (int)s;
+	urb->xfer = xfer;
+
+	TAILQ_INSERT_TAIL(&urb_entry_head, urb, entries);
+	selwakeup(&sce->rsel);
+}
+
+void ugen_read_async_callback(struct usbd_xfer *xfer, void *priv, usbd_status s) {
+	struct xfer_w *wrap = priv;
+	struct ctl_urb *urb = wrap->parent;
+	struct ugen_endpoint *sce = (struct ugen_endpoint *)urb->sce;
+
+	wrap->xfer = xfer;
+	urb->count--;
+	TAILQ_INSERT_TAIL(&urb->xfers_head, wrap, entries);
+
+	if (urb->count == 0) {
+		urb->status = (int)s;
+		TAILQ_INSERT_TAIL(&endpt_head, urb, entries);
+		selwakeup(&sce->rsel);
+	}
+}
+
 int
 ugen_match(struct device *parent, void *match, void *aux)
 {
@@ -150,6 +186,9 @@
 	usbd_status err;
 	int conf;
 
+	TAILQ_INIT(&urb_entry_head);
+	TAILQ_INIT(&endpt_head);
+
 	sc->sc_udev = udev = uaa->device;
 
 	if (usbd_get_devcnt(udev) > 0)
@@ -986,6 +1025,141 @@
 			return (EINVAL);
 		sce->timeout = *(int *)addr;
 		return (0);
+	case USB_ASYNC_SUBMIT:
+	{
+		struct ctl_urb *urb = (void *)addr;
+		struct usbd_xfer *xfer;
+		struct ctl_urb *kurb;
+		struct xfer_w *wrap;
+		void *buf;
+		int flags = 0;
+		int error = 0;
+		int left = urb->actlen;
+		int len;
+
+		kurb = malloc(sizeof(*kurb), M_TEMP, M_WAITOK);
+		if (kurb == NULL) {
+			printf("no mem kurb\n");
+			return (ENOMEM);
+		}
+		*kurb = *urb;
+		sce = &sc->sc_endpoints[endpt][IN];
+		if (sce->state & UGEN_SHORT_OK)
+			flags = USBD_SHORT_XFER_OK;
+		flags |= USBD_NO_COPY;
+		kurb->sce = sce;
+
+		kurb->count = left / UGEN_BBSIZE;
+		if (left % UGEN_BBSIZE)
+			kurb->count++;
+
+		TAILQ_INIT(&kurb->xfers_head);
+
+		while (left != 0) {
+			xfer = usbd_alloc_xfer(sc->sc_udev);
+			if (xfer == 0) {
+				printf("no mem xfer\n");
+				return (ENOMEM);
+			}
+			len = min(UGEN_BBSIZE, left);
+			buf = usbd_alloc_buffer(xfer, len);
+			if (buf == NULL) {
+				printf("no mem buf\n");
+				usbd_free_xfer(xfer);
+				return (ENOMEM);
+			}
+			wrap = malloc(sizeof(*wrap), M_TEMP, M_WAITOK);
+			if (wrap == NULL) {
+				printf("no mem wrap\n");
+				usbd_free_xfer(xfer);
+				return (ENOMEM);
+			}
+			wrap->parent = kurb;
+			left -= len;
+			usbd_setup_xfer(xfer, sce->pipeh, wrap, buf, len,
+			    flags, sce->timeout, (usbd_callback) ugen_read_async_callback);
+			err = usbd_transfer(xfer);
+			if (err != USBD_IN_PROGRESS) {
+				printf("transfer error\n");
+				usbd_clear_endpoint_stall(sce->pipeh);
+				if (err == USBD_INTERRUPTED) {
+					error = EINTR;
+				} else if (err == USBD_TIMEOUT) {
+					error = ETIMEDOUT;
+				} else {
+					error = EIO;
+				}
+				usbd_free_xfer(xfer);
+				free(wrap, M_TEMP, sizeof(*wrap));
+				// free main transfer, other
+				// transfers?
+				return (error);
+			}
+		}
+
+		return (0);
+	}
+	case USB_ASYNC_COMPLETE:
+	{
+		struct ctl_urb *urb = (void *)addr;
+		struct ctl_urb *kurb;
+		struct xfer_w *wrap;
+		struct usbd_xfer *xfer;
+		struct uio uio;
+		struct iovec iov;
+		int s;
+		int error = 0;
+
+		s = splusb();
+		kurb = TAILQ_FIRST(&endpt_head);
+		if (kurb == NULL) {
+			splx(s);
+			return (EIO);
+		}
+		TAILQ_REMOVE(&endpt_head, kurb, entries);
+		splx(s);
+
+		if (kurb->status == USBD_NORMAL_COMPLETION ||
+		    kurb->status == USBD_SHORT_XFER) {
+			iov.iov_base = (caddr_t)kurb->buffer;
+			iov.iov_len = kurb->actlen;
+			uio.uio_iov = &iov;
+			uio.uio_iovcnt = 1;
+			uio.uio_resid = kurb->actlen;
+			uio.uio_offset = 0;
+			uio.uio_segflg = UIO_USERSPACE;
+			uio.uio_rw = UIO_READ;
+			uio.uio_procp = p;
+
+			while (1) {
+				wrap = (struct xfer_w *)TAILQ_FIRST(&kurb->xfers_head);
+				if (wrap == NULL)
+					break;
+				xfer = (struct usbd_xfer *)wrap->xfer;
+				if (xfer->status == USBD_NORMAL_COMPLETION ||
+				    xfer->status == USBD_SHORT_XFER) {
+				} else {
+					printf("status not ok\n");
+					printf("status %d\n", (int)xfer->status);
+					return (-1);
+				}
+				error = uiomove(KERNADDR(&xfer->dmabuf, 0), xfer->actlen, &uio);
+				if (error) {
+					printf("move error\n");
+					usbd_free_xfer(xfer);
+					free(kurb, M_TEMP, sizeof(*kurb));
+					free(wrap, M_TEMP, sizeof(*wrap));
+					return (error);
+				}
+				TAILQ_REMOVE(&kurb->xfers_head, wrap, entries);
+				usbd_free_xfer(wrap->xfer);
+				free(wrap, M_TEMP, sizeof(*wrap));
+			}
+		}
+		*urb = *kurb;
+		free(kurb, M_TEMP, sizeof(*kurb));
+		return (0);
+	}
 	default:
 		break;
 	}
@@ -1143,11 +1317,14 @@
 	}
 	case USB_DO_REQUEST:
 	{
-		struct usb_ctl_request *ur = (void *)addr;
+		struct ctl_urb *urb = (void *)addr;
+		struct usb_ctl_request *ur = &urb->req;
 		int len = UGETW(ur->ucr_request.wLength);
+		struct ctl_urb *kurb;
+		struct usbd_xfer *xfer;
+		void *buf;
 		struct iovec iov;
 		struct uio uio;
-		void *ptr = 0;
 		int error = 0;
 
 		if (!(flag & FWRITE))
@@ -1160,9 +1337,18 @@
 		    (ur->ucr_request.bmRequestType == UT_WRITE_INTERFACE &&
 		     ur->ucr_request.bRequest == UR_SET_INTERFACE))
 			return (EINVAL);
-
 		if (len < 0 || len > 32767)
 			return (EINVAL);
+
+		xfer = usbd_alloc_xfer(sc->sc_udev);
+		if (xfer == NULL)
+			return (ENOMEM);
+		kurb = malloc(sizeof(*kurb), M_TEMP, M_WAITOK);
+		if (kurb == NULL) {
+			usbd_free_xfer(xfer);
+			return (ENOMEM);
+		}
+		*kurb = *urb;
 		if (len != 0) {
 			iov.iov_base = (caddr_t)ur->ucr_data;
 			iov.iov_len = len;
@@ -1175,34 +1361,90 @@
 				ur->ucr_request.bmRequestType & UT_READ ?
 				UIO_READ : UIO_WRITE;
 			uio.uio_procp = p;
-			ptr = malloc(len, M_TEMP, M_WAITOK);
+			buf = usbd_alloc_buffer(xfer, len);
+			if (buf == NULL) {
+				usbd_free_xfer(xfer);
+				free(kurb, M_TEMP, sizeof(*kurb));
+				return (ENOMEM);
+			}
 			if (uio.uio_rw == UIO_WRITE) {
-				error = uiomovei(ptr, len, &uio);
-				if (error)
-					goto ret;
+				error = uiomove(buf, len, &uio);
+				if (error) {
+					usbd_free_xfer(xfer);
+					free(kurb, M_TEMP, sizeof(*kurb));
+					return (error);
+				}
 			}
 		}
+
 		sce = &sc->sc_endpoints[endpt][IN];
-		err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request,
-			  ptr, ur->ucr_flags, &ur->ucr_actlen, sce->timeout);
-		if (err) {
-			error = EIO;
-			goto ret;
+		kurb->sce = sce;
+
+		error = usbd_request_async(xfer,
+		    &ur->ucr_request, kurb, (usbd_callback)
+		    ugen_request_async_callback);
+
+		if (error) {
+			free(kurb, M_TEMP, sizeof(*kurb));
+			usbd_free_xfer(xfer);
+			return (error);
 		}
-		/* Only if USBD_SHORT_XFER_OK is set. */
-		if (len > ur->ucr_actlen)
-			len = ur->ucr_actlen;
-		if (len != 0) {
-			if (uio.uio_rw == UIO_READ) {
-				error = uiomovei(ptr, len, &uio);
-				if (error)
-					goto ret;
+		break;
+	}
+	case USB_GET_COMPLETED:
+	{
+		struct ctl_urb *urb = (struct ctl_urb *)addr;
+		struct ctl_urb *kurb;
+		struct usbd_xfer *xfer;
+		struct usb_ctl_request *ur;
+		int len;
+		struct iovec iov;
+		struct uio uio;
+		int s;
+		int error = 0;
+
+		s = splusb();
+		kurb = TAILQ_FIRST(&urb_entry_head);
+		if (kurb == NULL) {
+			splx(s);
+			return (EIO);
+		}
+		TAILQ_REMOVE(&urb_entry_head, kurb, entries);
+		splx(s);
+		xfer = (struct usbd_xfer *)kurb->xfer;
+		if (kurb->status == USBD_NORMAL_COMPLETION ||
+		    kurb->status == USBD_SHORT_XFER) {
+			ur = &kurb->req;
+			len = UGETW(ur->ucr_request.wLength);
+			if (len > xfer->actlen)
+				len = xfer->actlen;
+			kurb->actlen = len;
+			if (len != 0) {
+				iov.iov_base = (caddr_t)ur->ucr_data;
+				iov.iov_len = len;
+				uio.uio_iov = &iov;
+				uio.uio_iovcnt = 1;
+				uio.uio_resid = len;
+				uio.uio_offset = 0;
+				uio.uio_segflg = UIO_USERSPACE;
+				uio.uio_rw =
+					ur->ucr_request.bmRequestType & UT_READ ?
+					UIO_READ : UIO_WRITE;
+				uio.uio_procp = p;
+				if (uio.uio_rw == UIO_READ) {
+					error = uiomove(KERNADDR(&xfer->dmabuf, 0), len, &uio);
+					if (error) {
+						usbd_free_xfer(xfer);
+						free(kurb, M_TEMP, sizeof(*kurb));
+						return (error);
+					}
+				}
 			}
 		}
-	ret:
-		if (ptr)
-			free(ptr, M_TEMP, 0);
-		return (error);
+		*urb = *kurb;
+		usbd_free_xfer(kurb->xfer);
+		free(kurb, M_TEMP, sizeof(*kurb));
+		break;
 	}
 	case USB_GET_DEVICEINFO:
 		usbd_fill_deviceinfo(sc->sc_udev,
@@ -1248,44 +1490,54 @@
 	if (sce == NULL)
 		return (POLLERR);
 #ifdef DIAGNOSTIC
-	if (!sce->edesc) {
-		printf("ugenpoll: no edesc\n");
-		return (POLLERR);
+	if (UGENENDPOINT(dev) != USB_CONTROL_ENDPOINT) {
+		if (!sce->edesc) {
+			printf("ugenpoll: no edesc\n");
+			return (POLLERR);
+		}
+		if (!sce->pipeh) {
+			printf("ugenpoll: no pipe\n");
+			return (POLLERR);
+		}
 	}
-	if (!sce->pipeh) {
-		printf("ugenpoll: no pipe\n");
-		return (POLLERR);
-	}
 #endif
 	s = splusb();
-	switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
-	case UE_INTERRUPT:
+	if (UGENENDPOINT(dev) == USB_CONTROL_ENDPOINT) {
 		if (events & (POLLIN | POLLRDNORM)) {
-			if (sce->q.c_cc > 0)
+			if (!TAILQ_EMPTY(&urb_entry_head))
 				revents |= events & (POLLIN | POLLRDNORM);
 			else
 				selrecord(p, &sce->rsel);
 		}
-		break;
-	case UE_ISOCHRONOUS:
-		if (events & (POLLIN | POLLRDNORM)) {
-			if (sce->cur != sce->fill)
-				revents |= events & (POLLIN | POLLRDNORM);
-			else
-				selrecord(p, &sce->rsel);
+	} else {
+		switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
+		case UE_INTERRUPT:
+			if (events & (POLLIN | POLLRDNORM)) {
+				if (sce->q.c_cc > 0)
+					revents |= events & (POLLIN | POLLRDNORM);
+				else
+					selrecord(p, &sce->rsel);
+			}
+			break;
+		case UE_ISOCHRONOUS:
+			if (events & (POLLIN | POLLRDNORM)) {
+				if (sce->cur != sce->fill)
+					revents |= events & (POLLIN | POLLRDNORM);
+				else
+					selrecord(p, &sce->rsel);
+			}
+			break;
+		case UE_BULK:
+			if (events & (POLLIN | POLLRDNORM)) {
+				if (!TAILQ_EMPTY(&endpt_head))
+					revents |= events & (POLLIN | POLLRDNORM);
+				else
+					selrecord(p, &sce->rsel);
+			}
+			break;
+		default:
+			break;
 		}
-		break;
-	case UE_BULK:
-		/*
-		 * We have no easy way of determining if a read will
-		 * yield any data or a write will happen.
-		 * Pretend they will.
-		 */
-		revents |= events &
-			   (POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM);
-		break;
-	default:
-		break;
 	}
 	splx(s);
 	return (revents);
