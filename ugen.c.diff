--- ugen.c.orig	Wed Jun  3 14:35:32 2015
+++ ugen.c	Mon Jun  8 16:15:39 2015
@@ -104,6 +104,16 @@
 	u_char sc_secondary;
 };
 
+struct ugen_async_info {
+        void (*callback)(void *priv, int id, void *data, int
+len);
+        void *priv;
+        void *buffer;
+        int id;
+};
+
+void ugen_cb(struct usbd_xfer *, void *, ubd_status);
+
 void ugenintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
 void ugen_isoc_rintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
 int ugen_do_read(struct ugen_softc *, int, struct uio *, int);
@@ -130,6 +140,37 @@
 	sizeof(struct ugen_softc), ugen_match, ugen_attach, ugen_detach
 };
 
+void ugen_cb(struct usbd_xfer *xfer, void *priv, ubd_status s) {
+	struct ugen_async_info *info = priv;
+	struct uio = info->uio;
+	void *ptr = info->buffer;
+
+	if (s == USBD_NORMAL_COMPLETION) {
+		/* Only if USBD_SHORT_XFER_OK is set. */
+		/* can i get the actlen from xfer? */
+		if (len > ur->ucr_actlen)
+			len = ur->ucr_actlen;
+		if (len != 0) {
+			/* if async, needs to happen in callback */
+			if (uio.uio_rw == UIO_READ) {
+				error = uiomovei(ptr, len, &uio);
+				// error = uiomovei(xfer->buffer, xfer->length, uio);
+				if (error)
+					goto ret;
+			}
+		}
+
+		info->callback(xfer, priv, s);
+	}
+
+ret:
+	if (ptr)
+		free(ptr, M_TEMP, 0);
+	usbd_free_xfer(xfer);
+	/* psignal */
+	return (error);
+}
+
 int
 ugen_match(struct device *parent, void *match, void *aux)
 {
@@ -1198,6 +1239,81 @@
 				if (error)
 					goto ret;
 			}
+		}
+	ret:
+		if (ptr)
+			free(ptr, M_TEMP, 0);
+		return (error);
+	}
+	case USB_DO_REQUEST_ASYNC:
+	{
+		struct usb_ctl_request *ur = (void *)addr;
+		struct usbd_xfer *xfer;
+		struct ugen_async_info *info;
+		int len = UGETW(ur-ucr_request.wLength);
+		struct iovec iov;
+		struct uio uio;
+		void *ptr = 0;
+		int error = 0;
+
+		if (!(flag & FWRITE))
+			return (EPERM);
+		/* Avoid requests that would damage the bus integrity. */
+		if ((ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
+		     ur->ucr_request.bRequest == UR_SET_ADDRESS) ||
+		    (ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
+		     ur->ucr_request.bRequest == UR_SET_CONFIG) ||
+		    (ur->ucr_request.bmRequestType == UT_WRITE_INTERFACE &&
+		     ur->ucr_request.bRequest == UR_SET_INTERFACE))
+			return (EINVAL);
+
+		if (len < 0 || len > 32767)
+			return (EINVAL);
+		if (len != 0) {
+			iov.iov_base = (caddr_t)ur->ucr_data;
+			iov.iov_len = len;
+			uio.uio_iov = &iov;
+			uio.uio_iovcnt = 1;
+			uio.uio_resid = len;
+			uio.uio_offset = 0;
+			uio.uio_segflg = UIO_USERSPACE;
+			uio.uio_rw =
+				ur->ucr_request.bmRequestType & UT_READ ?
+				UIO_READ : UIO_WRITE;
+			uio.uio_procp = p;
+			ptr = malloc(len, M_TEMP, M_WAITOK);
+			if (uio.uio_rw == UIO_WRITE) {
+				error = uiomovei(ptr, len, &uio);
+				if (error)
+					goto ret;
+			}
+		}
+
+		info->uio = uio;
+		info->buffer = ptr;
+		info->callback = ur->callback;
+
+		xfer = usbd_alloc_xfer(sc->sc_udev);
+
+		if (xfer == NULL)
+			return (USBD_NOMEM);
+
+		// usbd_alloc_buffer??
+
+		sce = &sc->sc_endpoints[endpt][IN];
+
+		/* but usbd_request_async calls
+		 * usbd_setup_default_xfer, and that call sets buffer to
+		 * null
+		 */
+		usbd_setup_xfer(xfer, sce->pipeh, NULL, ptr,
+		    len, ur->ucr_request.ucr_flags, sce->timeout, ugen_cb);
+
+		err = usbd_request_async(xfer, &ur->ucr_request, info, ugen_cb);
+
+		if (err) {
+			error = EIO;
+			goto ret;
 		}
 	ret:
 		if (ptr)
