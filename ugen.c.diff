--- ugen.c.orig	Wed Jun  3 14:35:32 2015
+++ ugen.c	Tue Jul 14 17:44:05 2015
@@ -1,4 +1,4 @@
-/*	$OpenBSD: ugen.c,v 1.81 2015/02/10 21:56:09 miod Exp $ */
+/*	$OpenBSD: ugen.c,v 1.84 2015/06/15 15:45:28 mpi Exp $ */
 /*	$NetBSD: ugen.c,v 1.63 2002/11/26 18:49:48 christos Exp $	*/
 /*	$FreeBSD: src/sys/dev/usb/ugen.c,v 1.26 1999/11/17 22:33:41 n_hibma Exp $	*/
 
@@ -46,9 +46,13 @@
 #include <sys/vnode.h>
 #include <sys/poll.h>
 
+#include <machine/bus.h>
+
 #include <dev/usb/usb.h>
 #include <dev/usb/usbdi.h>
 #include <dev/usb/usbdi_util.h>
+#include <dev/usb/usbdivar.h>
+#include <dev/usb/usb_mem.h>
 #include <dev/usb/usbdevs.h>
 
 #ifdef UGEN_DEBUG
@@ -89,6 +93,7 @@
 		void *dmabuf;
 		u_int16_t sizes[UGEN_NISORFRMS];
 	} isoreqs[UGEN_NISOREQS];
+	TAILQ_HEAD(, usb_ctl_request) queue;
 };
 
 struct ugen_softc {
@@ -104,12 +109,24 @@
 	u_char sc_secondary;
 };
 
+void ugen_async_callback_ctrl(struct usbd_xfer *, void *, usbd_status);
+void ugen_async_callback_bulk(struct usbd_xfer *, void *, usbd_status);
+int ugen_submit_ctrl(struct ugen_softc *, struct
+    usb_ctl_request *, struct proc *p);
+int ugen_submit_bulk(struct ugen_softc *, struct
+    usb_ctl_request *, struct proc *p);
+int ugen_complete_ctrl(struct usb_ctl_request *, struct proc
+    *p);
+int ugen_complete_bulk(struct usb_ctl_request *, struct proc
+    *p);
+
 void ugenintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
 void ugen_isoc_rintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
 int ugen_do_read(struct ugen_softc *, int, struct uio *, int);
 int ugen_do_write(struct ugen_softc *, int, struct uio *, int);
-int ugen_do_ioctl(struct ugen_softc *, int, u_long,
-			 caddr_t, int, struct proc *);
+int ugen_do_ioctl(struct ugen_softc *, int, u_long, caddr_t, int,
+	struct proc *);
+int ugen_do_close(struct ugen_softc *, int, int);
 int ugen_set_config(struct ugen_softc *sc, int configno);
 int ugen_set_interface(struct ugen_softc *, int, int);
 int ugen_get_alt_index(struct ugen_softc *sc, int ifaceidx);
@@ -130,6 +147,35 @@
 	sizeof(struct ugen_softc), ugen_match, ugen_attach, ugen_detach
 };
 
+void ugen_async_callback_ctrl(struct usbd_xfer *xfer, void *priv, usbd_status s) {
+	struct usb_ctl_request *req = priv;
+	struct ugen_endpoint *sce = (struct ugen_endpoint *)req->ucr_sce;
+
+	req->xfer = xfer;
+
+	TAILQ_INSERT_TAIL(&sce->queue, req, entries);
+	selwakeup(&sce->rsel);
+}
+
+void ugen_async_callback_bulk(struct usbd_xfer *xfer, void *priv, usbd_status s) {
+	struct xfer_w *wrap = priv;
+	struct usb_ctl_request *req = wrap->parent;
+	struct ugen_endpoint *sce = (struct ugen_endpoint *)req->ucr_sce;
+
+	//if (s == USBD_CANCELLED) {
+	//	return;
+	//}
+
+	wrap->xfer = xfer;
+	TAILQ_INSERT_TAIL(&req->xfers_head, wrap, entries);
+	req->ucr_count--;
+
+	if (req->ucr_count == 0) {
+		TAILQ_INSERT_TAIL(&sce->queue, req, entries);
+		selwakeup(&sce->rsel);
+	}
+}
+
 int
 ugen_match(struct device *parent, void *match, void *aux)
 {
@@ -282,6 +328,9 @@
 	if (sc->sc_is_open[endpt])
 		return (EBUSY);
 
+	sce = &sc->sc_endpoints[endpt][IN];
+	TAILQ_INIT(&sce->queue);
+
 	if (endpt == USB_CONTROL_ENDPOINT) {
 		sc->sc_is_open[USB_CONTROL_ENDPOINT] = 1;
 		return (0);
@@ -374,11 +423,10 @@
 				sce->isoreqs[i].dmabuf = buf;
 				for(j = 0; j < UGEN_NISORFRMS; ++j)
 					sce->isoreqs[i].sizes[j] = isize;
-				usbd_setup_isoc_xfer
-					(xfer, sce->pipeh, &sce->isoreqs[i],
-					 sce->isoreqs[i].sizes,
-					 UGEN_NISORFRMS, USBD_NO_COPY,
-					 ugen_isoc_rintr);
+				usbd_setup_isoc_xfer(xfer, sce->pipeh,
+				    &sce->isoreqs[i], sce->isoreqs[i].sizes,
+				    UGEN_NISORFRMS, USBD_NO_COPY |
+				    USBD_SHORT_XFER_OK, ugen_isoc_rintr);
 				(void)usbd_transfer(xfer);
 			}
 			DPRINTFN(5, ("ugenopen: isoc open done\n"));
@@ -399,23 +447,57 @@
 int
 ugenclose(dev_t dev, int flag, int mode, struct proc *p)
 {
+	struct ugen_softc *sc = ugen_cd.cd_devs[UGENUNIT(dev)];
 	int endpt = UGENENDPOINT(dev);
-	struct ugen_softc *sc;
-	struct ugen_endpoint *sce;
-	int dir;
-	int i;
+	int error;
 
-	sc = ugen_cd.cd_devs[UGENUNIT(dev)];
+	if (sc == NULL || usbd_is_dying(sc->sc_udev))
+		return (EIO);
 
 	DPRINTFN(5, ("ugenclose: flag=%d, mode=%d, unit=%d, endpt=%d\n",
 		     flag, mode, UGENUNIT(dev), endpt));
 
+	sc->sc_refcnt++;
+	error = ugen_do_close(sc, endpt, flag);
+	if (--sc->sc_refcnt < 0)
+		usb_detach_wakeup(&sc->sc_dev);
+
+	return (error);
+}
+
+int
+ugen_do_close(struct ugen_softc *sc, int endpt, int flag)
+{
+	struct ugen_endpoint *sce;
+	int dir, i;
+	struct usb_ctl_request *req;
+	struct xfer_w *wrap;
+
+
 #ifdef DIAGNOSTIC
 	if (!sc->sc_is_open[endpt]) {
 		printf("ugenclose: not open\n");
 		return (EINVAL);
 	}
 #endif
+	sce = &sc->sc_endpoints[endpt][IN];
+	if (endpt == USB_CONTROL_ENDPOINT) {
+		while ((req = TAILQ_FIRST(&sce->queue))) {
+			TAILQ_REMOVE(&sce->queue, req, entries);
+			usbd_free_xfer(req->xfer);
+			free(req, M_TEMP, sizeof(*req));
+		}
+	} else {
+		while ((req = TAILQ_FIRST(&sce->queue))) {
+			TAILQ_REMOVE(&sce->queue, req, entries);
+			while ((wrap = TAILQ_FIRST(&req->xfers_head))) {
+				TAILQ_REMOVE(&req->xfers_head, wrap, entries);
+				usbd_free_xfer(wrap->xfer);
+				free(wrap, M_TEMP, sizeof(*wrap));
+			}
+			free(req, M_TEMP, sizeof(*req));
+		}
+	}
 
 	if (endpt == USB_CONTROL_ENDPOINT) {
 		DPRINTFN(5, ("ugenclose: close control\n"));
@@ -432,7 +514,6 @@
 		DPRINTFN(5, ("ugenclose: endpt=%d dir=%d sce=%p\n",
 			     endpt, dir, sce));
 
-		usbd_abort_pipe(sce->pipeh);
 		usbd_close_pipe(sce->pipeh);
 		sce->pipeh = NULL;
 
@@ -740,9 +821,8 @@
 {
 	struct ugen_softc *sc = (struct ugen_softc *)self;
 	struct ugen_endpoint *sce;
-	int i, dir;
-	int s;
-	int maj, mn;
+	int i, dir, endptno;
+	int s, maj, mn;
 
 	DPRINTF(("ugen_detach: sc=%p flags=%d\n", sc, flags));
 
@@ -774,6 +854,10 @@
 	mn = self->dv_unit * USB_MAX_ENDPOINTS;
 	vdevgone(maj, mn, mn + USB_MAX_ENDPOINTS - 1, VCHR);
 
+	for (endptno = 0; endptno < USB_MAX_ENDPOINTS; endptno++) {
+		if (sc->sc_is_open[endptno])
+			ugen_do_close(sc, endptno, FREAD|FWRITE);
+	}
 	return (0);
 }
 
@@ -859,7 +943,7 @@
 	}
 
 	usbd_setup_isoc_xfer(xfer, sce->pipeh, req, req->sizes, UGEN_NISORFRMS,
-			     USBD_NO_COPY, ugen_isoc_rintr);
+	    USBD_NO_COPY | USBD_SHORT_XFER_OK, ugen_isoc_rintr);
 	(void)usbd_transfer(xfer);
 
 	if (sce->state & UGEN_ASLP) {
@@ -939,9 +1023,321 @@
 	return (usbd_get_interface_altindex(iface));
 }
 
+int ugen_submit_ctrl(struct ugen_softc *sc, struct
+    usb_ctl_request *req, struct proc *p) {
+	struct usb_ctl_request *kreq;
+	struct usbd_xfer *xfer;
+	int len;
+	void *buf;
+	struct uio uio;
+	struct iovec iov;
+	int error = 0;
+	int err;
+	int flags = 0;
+	struct ugen_endpoint *sce = req->ucr_sce;
+
+	len = UGETW(req->ucr_request.wLength);
+
+	/* Avoid requests that would damage the bus integrity. */
+	if ((req->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
+	     req->ucr_request.bRequest == UR_SET_ADDRESS) ||
+	    (req->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
+	     req->ucr_request.bRequest == UR_SET_CONFIG) ||
+	    (req->ucr_request.bmRequestType == UT_WRITE_INTERFACE &&
+	     req->ucr_request.bRequest == UR_SET_INTERFACE))
+		return (EINVAL);
+	if (len < 0 || len > 32767)
+		return (EINVAL);
+
+	kreq = malloc(sizeof(*kreq), M_TEMP, M_WAITOK);
+	if (kreq == NULL)
+		return (ENOMEM);
+	*kreq = *req;
+
+	xfer = usbd_alloc_xfer(sc->sc_udev);
+	if (xfer == NULL) {
+		free(kreq, M_TEMP, sizeof(*kreq));
+		return (ENOMEM);
+	}
+	if (len != 0) {
+		iov.iov_base = (caddr_t)req->ucr_data;
+		iov.iov_len = len;
+		uio.uio_iov = &iov;
+		uio.uio_iovcnt = 1;
+		uio.uio_resid = len;
+		uio.uio_offset = 0;
+		uio.uio_segflg = UIO_USERSPACE;
+		uio.uio_rw =
+		    req->ucr_request.bmRequestType & UT_READ ?
+		    UIO_READ : UIO_WRITE;
+		uio.uio_procp = p;
+		buf = usbd_alloc_buffer(xfer, len);
+		if (buf == NULL) {
+			usbd_free_xfer(xfer);
+			free(kreq, M_TEMP, sizeof(*kreq));
+			return (ENOMEM);
+		}
+		if (uio.uio_rw == UIO_WRITE) {
+			error = uiomove(buf, len, &uio);
+			if (error) {
+				usbd_free_xfer(xfer);
+				free(kreq, M_TEMP, sizeof(*kreq));
+				return (error);
+			}
+		}
+	}
+	if (req->ucr_flags & USBD_SHORT_XFER_OK)
+		flags = USBD_SHORT_XFER_OK;
+	usbd_setup_default_xfer(xfer, xfer->device, kreq,
+	    kreq->ucr_timeout, &kreq->ucr_request,
+	    NULL, len, flags | USBD_NO_COPY, ugen_async_callback_ctrl);
+	err = usbd_transfer(xfer);
+	if (err != USBD_IN_PROGRESS) {
+		usbd_clear_endpoint_stall(sce->pipeh);
+		if (err == USBD_INTERRUPTED)
+			error = EINTR;
+		else if (err == USBD_TIMEOUT)
+			error = ETIMEDOUT;
+		else
+			error = EIO;
+		usbd_free_xfer(xfer);
+		free(kreq, M_TEMP, sizeof(*kreq));
+		return (error);
+	}
+	return (0);
+}
+
+int ugen_submit_bulk(struct ugen_softc *sc, struct
+    usb_ctl_request *req, struct proc *p) {
+	struct usb_ctl_request *kreq;
+	struct usbd_xfer **xfers;
+	struct xfer_w *wrap;
+	int len;
+	void *buf;
+	int buf_len;
+	struct uio uio;
+	struct iovec iov;
+	int i;
+	//int k;
+	int error = 0;
+	int err;
+	int flags = 0;
+	struct ugen_endpoint *sce = req->ucr_sce;
+
+	len = req->ucr_actlen;
+
+	if (len < 0) /* are bulk transfers of length zero allowed? */
+		return (EINVAL);
+
+	kreq = malloc(sizeof(*kreq), M_TEMP, M_WAITOK);
+	if (kreq == NULL)
+		return (ENOMEM);
+	*kreq = *req;
+
+	if ((!(req->ucr_read)) && (len != 0)) {
+		iov.iov_base = (caddr_t)req->ucr_data;
+		iov.iov_len = len;
+		uio.uio_iov = &iov;
+		uio.uio_iovcnt = 1;
+		uio.uio_resid = len;
+		uio.uio_offset = 0;
+		uio.uio_segflg = UIO_USERSPACE;
+		uio.uio_rw = UIO_WRITE;
+		uio.uio_procp = p;
+	}
+
+	kreq->ucr_count = len / UGEN_BBSIZE;
+	if (len == 0)
+		kreq->ucr_count = 1;
+	else if (len % UGEN_BBSIZE)
+		kreq->ucr_count++;
+
+	TAILQ_INIT(&kreq->xfers_head);
+
+	for (i = 0; i < kreq->ucr_count; i++)
+		xfers[i] = NULL;
+
+	for (i = 0; i < kreq->ucr_count; i++) {
+		xfers[i] = usbd_alloc_xfer(sc->sc_udev);
+		if (xfers[i] == NULL) {
+			if (i == 0)
+				free(kreq, M_TEMP, sizeof(*kreq));
+			//for (k = 0; k < i; k++)
+			//	usbd_abort(xfers[k]);
+			/* still need to free kreq */
+			return (ENOMEM);
+		}
+		if (len != 0) {
+			buf_len = min(UGEN_BBSIZE, len);
+			buf = usbd_alloc_buffer(xfers[i], buf_len);
+			if (buf == NULL) {
+				usbd_free_xfer(xfers[i]);
+				if (i == 0)
+					free(kreq, M_TEMP, sizeof(*kreq));
+				//for (k = 0; k < i; k++)
+				//	usbd_abort(xfers[k]);
+				/* still need to free kreq */
+				return (ENOMEM);
+			}
+			if (!(req->ucr_read)) {
+				error = uiomove(buf, buf_len, &uio);
+				if (error) {
+					usbd_free_xfer(xfers[i]);
+					if (i == 0)
+						free(kreq, M_TEMP, sizeof(*kreq));
+					//for (k = 0; k < i; k++)
+					//	usbd_abort(xfers[k]);
+					/* still need to free kreq */
+					return (error);
+				}
+			}
+		}
+		wrap = malloc(sizeof(*wrap), M_TEMP, M_WAITOK);
+		if (wrap == NULL) {
+			usbd_free_xfer(xfers[i]);
+			if (i == 0)
+				free(kreq, M_TEMP, sizeof(*kreq));
+			//for (k = 0; k < i; k++)
+			//	usbd_abort(xfers[k]);
+			/* still need to free kreq */
+			return (ENOMEM);
+		}
+		wrap->parent = kreq;
+		len -= buf_len;
+		// should only the last packet have this
+		// flag set?
+		if (req->ucr_flags & USBD_FORCE_SHORT_XFER)
+			flags = USBD_FORCE_SHORT_XFER;
+		usbd_setup_xfer(xfers[i], sce->pipeh, wrap, NULL, buf_len,
+		    flags | USBD_NO_COPY,
+		    kreq->ucr_timeout, (usbd_callback) ugen_async_callback_bulk);
+		err = usbd_transfer(xfers[i]);
+		if (err != USBD_IN_PROGRESS) {
+			usbd_clear_endpoint_stall(sce->pipeh);
+			if (err == USBD_INTERRUPTED) {
+				error = EINTR;
+			} else if (err == USBD_TIMEOUT) {
+				error = ETIMEDOUT;
+			} else {
+				error = EIO;
+			}
+			usbd_free_xfer(xfers[i]);
+			free(wrap, M_TEMP, sizeof(*wrap));
+			if (i == 0)
+				free(kreq, M_TEMP, sizeof(*kreq));
+			//for (k = 0; k < i; k++)
+			//	usbd_abort(xfers[k]);
+			/* still need to free kreq */
+			return (error);
+		}
+	}
+	return (0);
+}
+
+int ugen_complete_ctrl(struct usb_ctl_request *req, struct
+    proc *p) {
+	struct usbd_xfer *xfer;
+	int len;
+	struct iovec iov;
+	struct uio uio;
+	int error = 0;
+
+	xfer = (struct usbd_xfer *)req->xfer;
+	req->ucr_status = xfer->status;
+	if (xfer->status == USBD_NORMAL_COMPLETION) {
+		len = UGETW(req->ucr_request.wLength);
+		if (len > xfer->actlen)
+			len = xfer->actlen;
+		req->ucr_actlen = len;
+		if (len != 0) {
+			iov.iov_base = (caddr_t)req->ucr_data;
+			iov.iov_len = len;
+			uio.uio_iov = &iov;
+			uio.uio_iovcnt = 1;
+			uio.uio_resid = len;
+			uio.uio_offset = 0;
+			uio.uio_segflg = UIO_USERSPACE;
+			uio.uio_rw =
+				req->ucr_request.bmRequestType & UT_READ ?
+				UIO_READ : UIO_WRITE;
+			uio.uio_procp = p;
+			if (uio.uio_rw == UIO_READ) {
+				error = uiomove(KERNADDR(&xfer->dmabuf, 0), len, &uio);
+				if (error) {
+					usbd_free_xfer(xfer);
+					return (error);
+				}
+			}
+		}
+	}
+	usbd_free_xfer(xfer);
+	return (0);
+}
+
+int ugen_complete_bulk(struct usb_ctl_request *req, struct
+    proc *p) {
+	struct usb_ctl_request *kreq;
+	struct xfer_w *wrap;
+	struct usbd_xfer *xfer;
+	struct uio uio;
+	struct iovec iov;
+	int s;
+	int error = 0;
+
+	if (req->ucr_read) {
+		iov.iov_base = (caddr_t)kreq->ucr_data;
+		iov.iov_len = kreq->ucr_actlen;
+		uio.uio_iov = &iov;
+		uio.uio_iovcnt = 1;
+		uio.uio_resid = kreq->ucr_actlen;
+		uio.uio_offset = 0;
+		uio.uio_segflg = UIO_USERSPACE;
+		uio.uio_rw = UIO_READ;
+		uio.uio_procp = p;
+	}
+
+	s = splusb();
+	while ((wrap = TAILQ_FIRST(&req->xfers_head))) {
+		TAILQ_REMOVE(&req->xfers_head, wrap, entries);
+		xfer = (struct usbd_xfer *)wrap->xfer;
+		if (xfer->status != USBD_NORMAL_COMPLETION) {
+			req->ucr_status = xfer->status;
+			usbd_free_xfer(xfer);
+			free(wrap, M_TEMP, sizeof(*wrap));
+			while ((wrap = TAILQ_FIRST(&req->xfers_head))) {
+				TAILQ_REMOVE(&req->xfers_head, wrap, entries);
+				usbd_free_xfer(wrap->xfer);
+				free(wrap, M_TEMP, sizeof(*wrap));
+			}
+			splx(s);
+			return (0);
+		}
+		if (req->ucr_read) {
+			error = uiomove(KERNADDR(&xfer->dmabuf, 0), xfer->actlen, &uio);
+			if (error) {
+				req->ucr_status = USBD_IOERROR;
+				usbd_free_xfer(xfer);
+				free(wrap, M_TEMP, sizeof(*wrap));
+				while ((wrap = TAILQ_FIRST(&req->xfers_head))) {
+					TAILQ_REMOVE(&req->xfers_head, wrap, entries);
+					usbd_free_xfer(wrap->xfer);
+					free(wrap, M_TEMP, sizeof(*wrap));
+				}
+				splx(s);
+				return (0);
+			}
+		}
+		usbd_free_xfer(wrap->xfer);
+		free(wrap, M_TEMP, sizeof(*wrap));
+	}
+	splx(s);
+	req->ucr_status = USBD_NORMAL_COMPLETION;
+	return (0);
+}
+
 int
-ugen_do_ioctl(struct ugen_softc *sc, int endpt, u_long cmd,
-	      caddr_t addr, int flag, struct proc *p)
+ugen_do_ioctl(struct ugen_softc *sc, int endpt, u_long cmd, caddr_t addr,
+    int flag, struct proc *p)
 {
 	struct ugen_endpoint *sce;
 	int err;
@@ -986,6 +1382,77 @@
 			return (EINVAL);
 		sce->timeout = *(int *)addr;
 		return (0);
+	case USB_DO_REQUEST:
+	{
+		struct usb_ctl_request *req = (void *)addr;
+		int error = 0;
+
+		sce = &sc->sc_endpoints[endpt][IN];
+		req->ucr_sce = sce;
+		if (!(flag & FWRITE))
+			return (EPERM);
+		if (endpt == USB_CONTROL_ENDPOINT) {
+			error = ugen_submit_ctrl(sc, req, p);
+			if (error)
+				return (error);
+		} else {
+			switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
+			case UE_INTERRUPT:
+			case UE_ISOCHRONOUS:
+				return (EINVAL);
+			case UE_BULK:
+				error = ugen_submit_bulk(sc, req, p);
+				if (error)
+					return (error);
+				break;
+			default:
+				return (EINVAL);
+			}
+		}
+		return (0);
+	}
+	case USB_GET_COMPLETED:
+	{
+
+		struct usb_ctl_request *req = (void *)addr;
+		struct usb_ctl_request *kreq;
+		int s;
+		int error = 0;
+
+		sce = &sc->sc_endpoints[endpt][IN];
+
+		s = splusb();
+		kreq = TAILQ_FIRST(&sce->queue);
+		if (kreq == NULL) {
+			splx(s);
+			return (EIO);
+		}
+		TAILQ_REMOVE(&sce->queue, kreq, entries);
+		splx(s);
+
+		if (endpt == USB_CONTROL_ENDPOINT) {
+			error = ugen_complete_ctrl(kreq, p);
+			if (error)
+				return (error);
+		} else {
+			switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
+			case UE_INTERRUPT:
+			case UE_ISOCHRONOUS:
+				return (EINVAL);
+			case UE_BULK:
+				error = ugen_complete_bulk(kreq, p);
+				if (error)
+					return (error);
+				break;
+			default:
+				return (EINVAL);
+			}
+		}
+
+		*req = *kreq;
+		free(kreq, M_TEMP, sizeof(*kreq));
+		return (0);
+	}
 	default:
 		break;
 	}
@@ -1141,69 +1608,6 @@
 			return (EINVAL);
 		break;
 	}
-	case USB_DO_REQUEST:
-	{
-		struct usb_ctl_request *ur = (void *)addr;
-		int len = UGETW(ur->ucr_request.wLength);
-		struct iovec iov;
-		struct uio uio;
-		void *ptr = 0;
-		int error = 0;
-
-		if (!(flag & FWRITE))
-			return (EPERM);
-		/* Avoid requests that would damage the bus integrity. */
-		if ((ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
-		     ur->ucr_request.bRequest == UR_SET_ADDRESS) ||
-		    (ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
-		     ur->ucr_request.bRequest == UR_SET_CONFIG) ||
-		    (ur->ucr_request.bmRequestType == UT_WRITE_INTERFACE &&
-		     ur->ucr_request.bRequest == UR_SET_INTERFACE))
-			return (EINVAL);
-
-		if (len < 0 || len > 32767)
-			return (EINVAL);
-		if (len != 0) {
-			iov.iov_base = (caddr_t)ur->ucr_data;
-			iov.iov_len = len;
-			uio.uio_iov = &iov;
-			uio.uio_iovcnt = 1;
-			uio.uio_resid = len;
-			uio.uio_offset = 0;
-			uio.uio_segflg = UIO_USERSPACE;
-			uio.uio_rw =
-				ur->ucr_request.bmRequestType & UT_READ ?
-				UIO_READ : UIO_WRITE;
-			uio.uio_procp = p;
-			ptr = malloc(len, M_TEMP, M_WAITOK);
-			if (uio.uio_rw == UIO_WRITE) {
-				error = uiomovei(ptr, len, &uio);
-				if (error)
-					goto ret;
-			}
-		}
-		sce = &sc->sc_endpoints[endpt][IN];
-		err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request,
-			  ptr, ur->ucr_flags, &ur->ucr_actlen, sce->timeout);
-		if (err) {
-			error = EIO;
-			goto ret;
-		}
-		/* Only if USBD_SHORT_XFER_OK is set. */
-		if (len > ur->ucr_actlen)
-			len = ur->ucr_actlen;
-		if (len != 0) {
-			if (uio.uio_rw == UIO_READ) {
-				error = uiomovei(ptr, len, &uio);
-				if (error)
-					goto ret;
-			}
-		}
-	ret:
-		if (ptr)
-			free(ptr, M_TEMP, 0);
-		return (error);
-	}
 	case USB_GET_DEVICEINFO:
 		usbd_fill_deviceinfo(sc->sc_udev,
 				     (struct usb_device_info *)addr, 1);
@@ -1248,44 +1652,54 @@
 	if (sce == NULL)
 		return (POLLERR);
 #ifdef DIAGNOSTIC
-	if (!sce->edesc) {
-		printf("ugenpoll: no edesc\n");
-		return (POLLERR);
+	if (UGENENDPOINT(dev) != USB_CONTROL_ENDPOINT) {
+		if (!sce->edesc) {
+			printf("ugenpoll: no edesc\n");
+			return (POLLERR);
+		}
+		if (!sce->pipeh) {
+			printf("ugenpoll: no pipe\n");
+			return (POLLERR);
+		}
 	}
-	if (!sce->pipeh) {
-		printf("ugenpoll: no pipe\n");
-		return (POLLERR);
-	}
 #endif
 	s = splusb();
-	switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
-	case UE_INTERRUPT:
+	if (UGENENDPOINT(dev) == USB_CONTROL_ENDPOINT) {
 		if (events & (POLLIN | POLLRDNORM)) {
-			if (sce->q.c_cc > 0)
+			if (!TAILQ_EMPTY(&sce->queue))
 				revents |= events & (POLLIN | POLLRDNORM);
 			else
 				selrecord(p, &sce->rsel);
 		}
-		break;
-	case UE_ISOCHRONOUS:
-		if (events & (POLLIN | POLLRDNORM)) {
-			if (sce->cur != sce->fill)
-				revents |= events & (POLLIN | POLLRDNORM);
-			else
-				selrecord(p, &sce->rsel);
+	} else {
+		switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
+		case UE_INTERRUPT:
+			if (events & (POLLIN | POLLRDNORM)) {
+				if (sce->q.c_cc > 0)
+					revents |= events & (POLLIN | POLLRDNORM);
+				else
+					selrecord(p, &sce->rsel);
+			}
+			break;
+		case UE_ISOCHRONOUS:
+			if (events & (POLLIN | POLLRDNORM)) {
+				if (sce->cur != sce->fill)
+					revents |= events & (POLLIN | POLLRDNORM);
+				else
+					selrecord(p, &sce->rsel);
+			}
+			break;
+		case UE_BULK:
+			if (events & (POLLIN | POLLRDNORM)) {
+				if (!TAILQ_EMPTY(&sce->queue))
+					revents |= events & (POLLIN | POLLRDNORM);
+				else
+					selrecord(p, &sce->rsel);
+			}
+			break;
+		default:
+			break;
 		}
-		break;
-	case UE_BULK:
-		/*
-		 * We have no easy way of determining if a read will
-		 * yield any data or a write will happen.
-		 * Pretend they will.
-		 */
-		revents |= events &
-			   (POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM);
-		break;
-	default:
-		break;
 	}
 	splx(s);
 	return (revents);
