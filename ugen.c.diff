--- ugen.c.orig	Wed Jun  3 14:35:32 2015
+++ ugen.c	Fri Jun  5 15:22:09 2015
@@ -102,8 +102,11 @@
 
 	int sc_refcnt;
 	u_char sc_secondary;
+	struct proc        *async;
 };
 
+void ugen_cb(struct usbd_xfer *, void *, ubd_status);
+
 void ugenintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
 void ugen_isoc_rintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
 int ugen_do_read(struct ugen_softc *, int, struct uio *, int);
@@ -130,6 +133,38 @@
 	sizeof(struct ugen_softc), ugen_match, ugen_attach, ugen_detach
 };
 
+/* invoked upon completion of transfer whether successful or
+ * not
+ */
+void ugen_cb(struct usbd_xfer *xfer, void *, ubd_status s) {
+	// if (xfer->status == USBD_NORMAL_COMPLETION)
+	if (ubd_status == USBD_NORMAL_COMPLETION)
+	/* uiomove if a read, if a write then we're done */
+	/* how do I know the xfer was a read? */
+	/* Get the uio that we saved when submitting the transfer */
+	if (ubd_status is complete and it was a read)	
+		error = uiomovei(xfer->buffer, xfer->length, uio);
+	usbd_free_xfer(xfer);
+	/* psignal */
+
+/* for control requests */
+		/* Only if USBD_SHORT_XFER_OK is set. */
+		if (len > ur->ucr_actlen)
+			len = ur->ucr_actlen;
+		if (len != 0) {
+			/* if async, needs to happen in callback */
+			if (uio.uio_rw == UIO_READ) {
+				error = uiomovei(ptr, len, &uio);
+				if (error)
+					goto ret;
+			}
+		}
+	ret:
+		if (ptr)
+			free(ptr, M_TEMP, 0);
+		return (error);
+}
+
 int
 ugen_match(struct device *parent, void *match, void *aux)
 {
@@ -964,6 +999,14 @@
 	case FIONBIO:
 		/* All handled in the upper FS layer. */
 		return (0);
+	case FIOASYNC:
+		if (*(int *)addr) {
+			if (sc->async)
+				return EBUSY;
+			sc->async = p;
+		} else
+			sc->async = 0;
+		return (0);
 	case USB_SET_SHORT_XFER:
 		if (endpt == USB_CONTROL_ENDPOINT)
 			return (EINVAL);
@@ -986,6 +1029,35 @@
 			return (EINVAL);
 		sce->timeout = *(int *)addr;
 		return (0);
+	case USB_DO_BULK_TRANSFER:
+	{
+		struct usb_transfer *transfer = (void *)addr;
+		/* is this a read or a write? */
+		struct usbd_pipe *pipe = &sc->sc_endpoints[indpt][IN]->pipeh;
+		/* should we make a new struct representing
+ 		 * the transfer while it is in progress?
+ 		 * the structure could store the uio info
+		 */
+		/* If this is a write, we should make a uio
+ 		 * and do a uiomove like in USB_DO_REQUEST
+		 */
+		void *buffer = transfer->buffer;
+		uint32_t length = transfer->length;
+		uint16_t flags = transfer->flags;
+		struct usbd_xfer *xfer;
+		usbd_setup_xfer(&xfer, pipe, buffer, length,
+		                flags, pipe->timeout, ugen_cb);
+		usbd_transfer(xfer);
+		/* create a uio structure and save it
+		 * somewhere for when the callback returns with the results*/
+		return (0);
+	}
+	case USB_DO_ISOCHRONOUS_TRANSFER:
+	{
+	}
+	case USB_DO_INTERRUPT_TRANSFER:
+	{
+	}
 	default:
 		break;
 	}
@@ -1183,8 +1255,17 @@
 			}
 		}
 		sce = &sc->sc_endpoints[endpt][IN];
-		err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request,
-			  ptr, ur->ucr_flags, &ur->ucr_actlen, sce->timeout);
+		// err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request,
+		//           ptr, ur->ucr_flags, &ur->ucr_actlen, sce->timeout);
+		// usbd_status
+		// usbd_request_async(struct usbd_xfer *xfer,
+		//                    usb_device_request_t *req,
+		//                    void *priv, usbd_callback callback)
+		// usbd_request_async_flags doesnt exist?
+		xfer = usbd_alloc_xfer(sc->sc_udev);
+		if (xfer == NULL)
+			return (USBD_NOMEM);
+		err = usbd_request_async(xfer, &ur->ucr_request, NULL, ugen_cb);
 		if (err) {
 			error = EIO;
 			goto ret;
@@ -1193,6 +1274,7 @@
 		if (len > ur->ucr_actlen)
 			len = ur->ucr_actlen;
 		if (len != 0) {
+			/* if async, needs to happen in callback */
 			if (uio.uio_rw == UIO_READ) {
 				error = uiomovei(ptr, len, &uio);
 				if (error)
