--- ugen.c.orig	Wed Jun  3 14:35:32 2015
+++ ugen.c	Fri Jun 19 04:03:59 2015
@@ -104,6 +104,8 @@
 	u_char sc_secondary;
 };
 
+void ugen_request_async_callback(struct usbd_xfer *, void *, usbd_status);
+
 void ugenintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
 void ugen_isoc_rintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
 int ugen_do_read(struct ugen_softc *, int, struct uio *, int);
@@ -130,6 +132,47 @@
 	sizeof(struct ugen_softc), ugen_match, ugen_attach, ugen_detach
 };
 
+struct ugen_info {
+	struct uio	uio;
+	void	       *ptr;
+	int		length;
+	struct ctl_urb *urb;
+};
+
+struct urb_entry {
+        struct ctl_urb	       *urb;
+        TAILQ_ENTRY(urb_entry)	entries;
+};
+
+TAILQ_HEAD(, urb_entry) urb_entry_head = TAILQ_HEAD_INITIALIZER(urb_entry_head);
+
+void ugen_request_async_callback(struct usbd_xfer *xfer, void *priv, usbd_status s) {
+	struct ugen_info *info = priv;
+	struct urb_entry *ue;
+	int len = info->length;
+	int error = 0;
+
+        if (s == USBD_NORMAL_COMPLETION) {
+		/* Only if USBD_SHORT_XFER_OK is set. */
+		if (len > info->urb->req.ucr_actlen)
+			len = info->urb->req.ucr_actlen;
+		if (len != 0) {
+			if (info->uio.uio_rw == UIO_READ) {
+				error = uiomovei(info->ptr, len, &info->uio);
+				if (error)
+					goto ret;
+			}
+		}
+
+		ue = malloc(sizeof(*ue), M_TEMP, M_WAITOK);
+		ue->urb = info->urb;
+		TAILQ_INSERT_TAIL(&urb_entry_head, ue, entries);
+        }
+ret:
+	free(info, M_TEMP, sizeof(*info));
+	usbd_free_xfer(xfer);
+}
+
 int
 ugen_match(struct device *parent, void *match, void *aux)
 {
@@ -1143,7 +1186,10 @@
 	}
 	case USB_DO_REQUEST:
 	{
-		struct usb_ctl_request *ur = (void *)addr;
+		struct ctl_urb *urb = (void *)addr;
+		struct usb_ctl_request *ur = &urb->req;
+		struct usbd_xfer *xfer;
+		struct ugen_info *info;
 		int len = UGETW(ur->ucr_request.wLength);
 		struct iovec iov;
 		struct uio uio;
@@ -1163,6 +1209,12 @@
 
 		if (len < 0 || len > 32767)
 			return (EINVAL);
+
+		xfer = usbd_alloc_xfer(sc->sc_udev);
+
+		if (xfer == NULL)
+			return (USBD_NOMEM);
+
 		if (len != 0) {
 			iov.iov_base = (caddr_t)ur->ucr_data;
 			iov.iov_len = len;
@@ -1175,34 +1227,60 @@
 				ur->ucr_request.bmRequestType & UT_READ ?
 				UIO_READ : UIO_WRITE;
 			uio.uio_procp = p;
-			ptr = malloc(len, M_TEMP, M_WAITOK);
+			ptr = usbd_alloc_buffer(xfer, len);
+			if (ptr == 0) {
+				usbd_free_xfer(xfer);
+				return (0);
+			}
 			if (uio.uio_rw == UIO_WRITE) {
 				error = uiomovei(ptr, len, &uio);
-				if (error)
-					goto ret;
+				if (error) {
+					usbd_free_xfer(xfer);
+					return (error);
+				}
 			}
 		}
+
 		sce = &sc->sc_endpoints[endpt][IN];
-		err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request,
-			  ptr, ur->ucr_flags, &ur->ucr_actlen, sce->timeout);
+
+		// usbd_setup_xfer(xfer, sce->pipeh, NULL, ptr,
+		//    len, ur->ucr_flags, sce->timeout, (usbd_callback) ugen_request_async_callback);
+
+		info = malloc(sizeof(*info), M_TEMP, M_NOWAIT);
+		if (info == NULL) {
+			usbd_free_xfer(xfer);
+	                return (-1);
+		}
+
+		info->uio = uio;
+		info->ptr = ptr;
+		info->length = len;
+		info->urb = urb;
+
+		err = usbd_request_async(xfer, &ur->ucr_request, info, (usbd_callback) ugen_request_async_callback);
+
 		if (err) {
 			error = EIO;
-			goto ret;
+			free(info, M_TEMP, sizeof(*info));
+			usbd_free_xfer(xfer);
+			return (error);
 		}
-		/* Only if USBD_SHORT_XFER_OK is set. */
-		if (len > ur->ucr_actlen)
-			len = ur->ucr_actlen;
-		if (len != 0) {
-			if (uio.uio_rw == UIO_READ) {
-				error = uiomovei(ptr, len, &uio);
-				if (error)
-					goto ret;
-			}
+		return (0);
+	}
+	case USB_GET_COMPLETED:
+	{
+		struct ctl_urb **ptr = (struct ctl_urb **)addr;
+		struct urb_entry *ue;
+
+		if (TAILQ_EMPTY(&urb_entry_head)) {
+			*ptr = NULL;
+			return 0;
 		}
-	ret:
-		if (ptr)
-			free(ptr, M_TEMP, 0);
-		return (error);
+		ue = TAILQ_FIRST(&urb_entry_head);
+		*ptr = ue->urb;
+		TAILQ_REMOVE(&urb_entry_head, ue, entries);
+		free(ue, M_TEMP, sizeof(*ue));
+		return (0);
 	}
 	case USB_GET_DEVICEINFO:
 		usbd_fill_deviceinfo(sc->sc_udev,
