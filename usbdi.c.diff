--- usbdi.c.orig	Mon Jul 20 19:20:47 2015
+++ usbdi.c	Fri Jul 24 17:44:16 2015
@@ -351,6 +351,23 @@
 	return (xfer->status);
 }
 
+void
+usbd_abort_transfer(struct usbd_xfer *xfer) {
+	struct usbd_pipe *pipe = xfer->pipe;
+
+#ifdef DIAGNOSTIC
+	if (pipe == NULL) {
+		printf("usbd_abort_transfer: pipe == NULL\n");
+		return;
+	}
+	if (pipe->methods == NULL || pipe->methods->abort == NULL) {
+		printf("usbd_abort_transfer: pipe=%p no abort method\n", pipe);
+		return;
+	}
+#endif
+	pipe->methods->abort(xfer);
+}
+
 void *
 usbd_alloc_buffer(struct usbd_xfer *xfer, u_int32_t size)
 {
@@ -712,6 +729,9 @@
 usb_transfer_complete(struct usbd_xfer *xfer)
 {
 	struct usbd_pipe *pipe = xfer->pipe;
+	struct usbd_xfer *np;
+	struct usbd_xfer *prev;
+	struct usbd_xfer *temp;
 	int polling;
 
 	SPLUSBCHECK;
@@ -758,13 +778,18 @@
 
 	if (!pipe->repeat) {
 		/* Remove request from queue. */
-#ifdef DIAGNOSTIC
-		if (xfer != SIMPLEQ_FIRST(&pipe->queue))
-			printf("usb_transfer_complete: bad dequeue %p != %p\n",
-			    xfer, SIMPLEQ_FIRST(&pipe->queue));
 		xfer->busy_free = XFER_FREE;
-#endif
-		SIMPLEQ_REMOVE_HEAD(&pipe->queue, next);
+		prev = NULL;
+		SIMPLEQ_FOREACH_SAFE(np, &pipe->queue, next, temp) {
+			if (np == xfer) {
+				if (prev)
+					SIMPLEQ_REMOVE_AFTER(&pipe->queue, prev, next);
+				else
+					SIMPLEQ_REMOVE_HEAD(&pipe->queue, next);
+				break;
+			}
+			prev = np;
+		}
 	}
 	DPRINTFN(5,("usb_transfer_complete: repeat=%d new head=%p\n",
 	    pipe->repeat, SIMPLEQ_FIRST(&pipe->queue)));
@@ -1112,4 +1137,3 @@
 		USETW2(p->bString[i], 0, s[i]);
 	return (2 * i + 2);
 }
-
