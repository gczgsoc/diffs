--- openbsd_usb.c.orig	Wed Jun  3 15:22:32 2015
+++ openbsd_usb.c	Thu Jun  4 18:16:25 2015
@@ -75,6 +75,8 @@
 static int obsd_cancel_transfer(struct usbi_transfer *);
 static void obsd_clear_transfer_priv(struct usbi_transfer *);
 static int obsd_handle_transfer_completion(struct usbi_transfer *);
+static int obsd_handle_events(struct libusb_context *ctx,
+                              struct pollfd *fds, POLL_NFDS_TYPE nfds, int num_ready)
 static int obsd_clock_gettime(int, struct timespec *);
 
 /*
@@ -84,6 +86,7 @@
 static int _cache_active_config_descriptor(struct libusb_device *);
 static int _sync_control_transfer(struct usbi_transfer *);
 static int _sync_gen_transfer(struct usbi_transfer *);
+static int _async_gen_transfer(struct usbi_transfer *);
 static int _access_endpoint(struct libusb_transfer *);
 
 static int _bus_open(int);
@@ -127,7 +130,7 @@
 	obsd_cancel_transfer,
 	obsd_clear_transfer_priv,
 
-	NULL,				/* handle_events() */
+	obsd_handle_events,
 	obsd_handle_transfer_completion,
 
 	obsd_clock_gettime,
@@ -534,6 +537,15 @@
 }
 
 int
+obsd_handle_events(struct libusb_context *ctx,
+                   struct pollfd *fds, POLL_NFDS_TYPE nfds, int num_ready)
+{
+	/* fetch completion code and data from completed
+	 * transfer */
+	return 0;
+}
+
+int
 obsd_clock_gettime(int clkid, struct timespec *tp)
 {
 	usbi_dbg("clock %d", clkid);
@@ -710,10 +722,56 @@
 			if ((fd = open(devnode, mode)) < 0)
 				return (-1);
 
+		fcntl(fd, F_SETFL, O_ASYNC);
+
 		hpriv->endpoints[endpt] = fd;
 	}
 
 	return (hpriv->endpoints[endpt]);
+}
+
+int
+_async_gen_transfer(struct usbi_transfer *itransfer)
+{
+	struct libusb_transfer *transfer;
+	/* struct usb_transfer {
+	 *	int     in;       /* read or write? */
+	 *	void    *buffer;  /* data to be transfered */
+	 *	uint32_t length;  /* length of data */
+	 *	uint16_t flags;   /* flags for usbd */
+	 *};
+	 */
+	struct usb_transfer *t;
+	struct device_priv *dpriv;
+	int fd, nr = 1;
+
+	transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
+	dpriv = (struct device_priv *)transfer->dev_handle->dev->os_priv;
+
+	if (dpriv->devname == NULL)
+		return (LIBUSB_ERROR_NOT_SUPPORTED);
+
+	/*
+	 * Bulk, Interrupt or Isochronous transfer depends on the
+	 * endpoint and thus the node to open.
+	 */
+	if ((fd = _access_endpoint(transfer)) < 0)
+		return _errno_to_libusb(errno);
+
+	if ((ioctl(fd, USB_SET_TIMEOUT, &transfer->timeout)) < 0)
+		return _errno_to_libusb(errno);
+
+	/* DONT CALL READ OR WRITE, use ioctl */
+	t->in = IS_XFERIN(transfer);
+	t->buffer = transfer->buffer;
+	t->length = transfer->length;
+	t->flags = transfer->flags;
+	nr = ioctl(fd, DO_TRANSFER, &t);
+
+	if (nr < 0)
+		return _errno_to_libusb(errno);
+
+	return (0);
 }
 
 int
