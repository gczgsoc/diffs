--- openbsd_usb.c.orig	Wed Jun  3 15:22:32 2015
+++ openbsd_usb.c	Sun Jun  7 16:01:56 2015
@@ -75,6 +75,8 @@
 static int obsd_cancel_transfer(struct usbi_transfer *);
 static void obsd_clear_transfer_priv(struct usbi_transfer *);
 static int obsd_handle_transfer_completion(struct usbi_transfer *);
+static int obsd_handle_events(struct libusb_context *ctx,
+                              struct pollfd *fds, POLL_NFDS_TYPE nfds, int num_ready)
 static int obsd_clock_gettime(int, struct timespec *);
 
 /*
@@ -83,8 +85,10 @@
 static int _errno_to_libusb(int);
 static int _cache_active_config_descriptor(struct libusb_device *);
 static int _sync_control_transfer(struct usbi_transfer *);
+static int _async_control_transfer(struct usbi_transfer *);
 static int _sync_gen_transfer(struct usbi_transfer *);
 static int _access_endpoint(struct libusb_transfer *);
+void obsd_callback(struct usbd_xfer *, void *, usbd_status);
 
 static int _bus_open(int);
 
@@ -127,7 +131,7 @@
 	obsd_cancel_transfer,
 	obsd_clear_transfer_priv,
 
-	NULL,				/* handle_events() */
+	obsd_handle_events,
 	obsd_handle_transfer_completion,
 
 	obsd_clock_gettime,
@@ -139,6 +143,10 @@
 #define DEVPATH	"/dev/"
 #define USBDEV	DEVPATH "usb"
 
+void
+obsd_callback(struct usbd_xfer *, void *, usbd_status) {
+}
+
 int
 obsd_get_device_list(struct libusb_context * ctx,
 	struct discovered_devs **discdevs)
@@ -261,6 +269,8 @@
 		usbi_dbg("open %s: fd %d", devnode, dpriv->fd);
 	}
 
+	/* usbdi_add_pollfd(HANDLE_CTX(handle), hpriv->fd, POLLOUT) */
+
 	return (LIBUSB_SUCCESS);
 }
 
@@ -479,7 +489,7 @@
 
 	switch (transfer->type) {
 	case LIBUSB_TRANSFER_TYPE_CONTROL:
-		err = _sync_control_transfer(itransfer);
+		err = _async_control_transfer(itransfer);
 		break;
 	case LIBUSB_TRANSFER_TYPE_ISOCHRONOUS:
 		if (IS_XFEROUT(transfer)) {
@@ -506,9 +516,9 @@
 	if (err)
 		return (err);
 
-	usbi_signal_transfer_completion(itransfer);
+	// usbi_signal_transfer_completion(itransfer);
 
-	return (LIBUSB_SUCCESS);
+	return (LIBUSB_SUCCESS); // does async return success?
 }
 
 int
@@ -534,6 +544,84 @@
 }
 
 int
+obsd_handle_events(struct libusb_context *ctx,
+                   struct pollfd *fds, POLL_NFDS_TYPE nfds, int num_ready)
+{
+
+	/* for each fd in fds, check pollfd->revents, if
+	 * events then get handle for fd, if POLLERR handle
+	 * error, otherwise reapurb?  I guess ugen should
+	 * keep record of all completed requests then this
+	 * can call handle_completition like linux?
+	 */
+
+	for (i = 0; i < nfds && num_ready > 0; i++) {
+		struct pollfd *pollfd = &fds[i];
+		struct libusb_device_handle *h;
+		struct device_priv *dpriv = NULL;
+
+		if (!pollfd->revents)
+			continue;
+
+		num_ready--;
+		list_for_each_entry(h, &ctx->open_devs, list, struct libusb_device_handle) {
+			dpriv = _device_handle_priv(handle);
+			if (dpriv->fd == pollfd->fd)
+				break;
+		}
+		if (!dpriv || dpriv->fd != pollfd->fd) {
+			usbi_err(ctx, "cannot find handle for fd %d", pollfd->fd);
+			continue;
+		}
+		if (pollfd->revents & POLLERR) {
+			usbi_remove_pollfd(HANDLE_CTX(handle), dpriv->fd);
+			usbi_handle_disconnect(handle);
+			if (h->dev->attached)
+				continue;
+		}
+		do {
+			r = reap_for_handle(handle);
+		} while (r == 0);
+		if (r == 1 || r == LIBUSB_ERROR_NO_DEVICE)
+			continue;
+		else if (r < 0)
+			goto out;
+	}
+	r = 0;
+out:
+	usbi_mutex_unlock(&ctx->open_devs_lock);
+	return r;
+
+	/* fetch completion code and data from completed
+	 * transfer */
+
+	/* this is how ubsdi.c waits for completion of a
+	 * transfer
+	 */
+	/* Sync transfer, wait for completion. */
+	if (err != USBD_IN_PROGRESS)
+		return (err);
+	s = splusb();
+	while (!xfer->done) {
+		if (pipe->device->bus->use_polling)
+			panic("usbd_transfer: not done");
+		flags = PRIBIO | (xfer->flags & USBD_CATCH ? PCATCH : 0);
+
+		err = tsleep(xfer, flags, "usbsyn", 0);
+		if (err && !xfer->done) {
+			usbd_abort_pipe(pipe);
+			if (err == EINTR)
+				xfer->status = USBD_INTERRUPTED;
+			else
+				xfer->status = USBD_TIMEOUT;
+		}
+	}
+	splx(s);
+	return (xfer->status);
+	return 0;
+}
+
+int
 obsd_clock_gettime(int clkid, struct timespec *tp)
 {
 	usbi_dbg("clock %d", clkid);
@@ -679,6 +767,73 @@
 	itransfer->transferred = req.ucr_actlen;
 
 	usbi_dbg("transferred %d", itransfer->transferred);
+
+	return (0);
+}
+
+int
+_async_control_transfer(struct usbi_transfer *itransfer)
+{
+	struct libusb_transfer *transfer;
+	struct libusb_control_setup *setup;
+	struct device_priv *dpriv;
+	struct usb_ctl_request req;
+
+	transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
+	dpriv = (struct device_priv *)transfer->dev_handle->dev->os_priv;
+	setup = (struct libusb_control_setup *)transfer->buffer;
+
+	usbi_dbg("type %x request %x value %x index %d length %d timeout %d",
+	    setup->bmRequestType, setup->bRequest,
+	    libusb_le16_to_cpu(setup->wValue),
+	    libusb_le16_to_cpu(setup->wIndex),
+	    libusb_le16_to_cpu(setup->wLength), transfer->timeout);
+
+	req.ucr_addr = transfer->dev_handle->dev->device_address;
+	req.ucr_request.bmRequestType = setup->bmRequestType;
+	req.ucr_request.bRequest = setup->bRequest;
+	/* Don't use USETW, libusb already deals with the endianness */
+	(*(uint16_t *)req.ucr_request.wValue) = setup->wValue;
+	(*(uint16_t *)req.ucr_request.wIndex) = setup->wIndex;
+	(*(uint16_t *)req.ucr_request.wLength) = setup->wLength;
+	req.ucr_data = transfer->buffer + LIBUSB_CONTROL_SETUP_SIZE;
+	req.callback = obsd_callback;
+
+	if ((transfer->flags & LIBUSB_TRANSFER_SHORT_NOT_OK) == 0)
+		req.ucr_flags = USBD_SHORT_XFER_OK;
+
+	if (dpriv->devname == NULL) {
+		/*
+		 * XXX If the device is not attached to ugen(4) it is
+		 * XXX still possible to submit a control transfer but
+		 * XXX with the default timeout only.
+		 */
+		int fd, err;
+
+		if ((fd = _bus_open(transfer->dev_handle->dev->bus_number)) < 0)
+			return _errno_to_libusb(errno);
+
+		if ((ioctl(fd, USB_REQUEST, &req)) < 0) {
+			err = errno;
+			close(fd);
+			return _errno_to_libusb(err);
+		}
+		// can we close it if we submitted
+		// asynchronously?
+		close(fd);
+	} else {
+		if ((ioctl(dpriv->fd, USB_SET_TIMEOUT, &transfer->timeout)) < 0)
+			return _errno_to_libusb(errno);
+
+		if ((ioctl(dpriv->fd, USB_DO_REQUEST_ASYNC, &req)) < 0)
+			return _errno_to_libusb(errno);
+	}
+
+	// is this set if it was asynchronous or do we do
+	// this in the callback?
+	// itransfer->transferred = req.ucr_actlen;
+
+	// usbi_dbg("transferred %d", itransfer->transferred);
 
 	return (0);
 }
