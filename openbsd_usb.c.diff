--- openbsd_usb.c.orig	Wed Jun  3 15:22:32 2015
+++ openbsd_usb.c	Tue Jul  7 04:47:45 2015
@@ -29,6 +29,7 @@
 #include <unistd.h>
 
 #include <dev/usb/usb.h>
+#include <dev/usb/usbdi.h>
 
 #include "libusbi.h"
 
@@ -74,6 +75,8 @@
 static int obsd_submit_transfer(struct usbi_transfer *);
 static int obsd_cancel_transfer(struct usbi_transfer *);
 static void obsd_clear_transfer_priv(struct usbi_transfer *);
+static int obsd_handle_events(struct libusb_context *ctx, struct pollfd *,
+    nfds_t, int);
 static int obsd_handle_transfer_completion(struct usbi_transfer *);
 static int obsd_clock_gettime(int, struct timespec *);
 
@@ -83,6 +86,7 @@
 static int _errno_to_libusb(int);
 static int _cache_active_config_descriptor(struct libusb_device *);
 static int _sync_control_transfer(struct usbi_transfer *);
+static int _sync_bulk_transfer(struct usbi_transfer *itransfer);
 static int _sync_gen_transfer(struct usbi_transfer *);
 static int _access_endpoint(struct libusb_transfer *);
 
@@ -127,7 +131,7 @@
 	obsd_cancel_transfer,
 	obsd_clear_transfer_priv,
 
-	NULL,				/* handle_events() */
+	obsd_handle_events,
 	obsd_handle_transfer_completion,
 
 	obsd_clock_gettime,
@@ -258,6 +262,7 @@
 		if (dpriv->fd < 0)
 			return _errno_to_libusb(errno);
 
+		usbi_add_pollfd(HANDLE_CTX(handle), dpriv->fd, POLLIN | POLLRDNORM);
 		usbi_dbg("open %s: fd %d", devnode, dpriv->fd);
 	}
 
@@ -470,12 +475,14 @@
 {
 	struct libusb_transfer *transfer;
 	struct handle_priv *hpriv;
+	struct device_priv *dpriv;
 	int err = 0;
 
 	usbi_dbg("");
 
 	transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
 	hpriv = (struct handle_priv *)transfer->dev_handle->os_priv;
+	dpriv = (struct device_priv *)transfer->dev_handle->dev->os_priv;
 
 	switch (transfer->type) {
 	case LIBUSB_TRANSFER_TYPE_CONTROL:
@@ -490,6 +497,13 @@
 		err = _sync_gen_transfer(itransfer);
 		break;
 	case LIBUSB_TRANSFER_TYPE_BULK:
+		if (IS_XFEROUT(transfer) &&
+		    transfer->flags & LIBUSB_TRANSFER_ADD_ZERO_PACKET) {
+			err = LIBUSB_ERROR_NOT_SUPPORTED;
+			break;
+		}
+		err = _sync_bulk_transfer(itransfer);
+		break;
 	case LIBUSB_TRANSFER_TYPE_INTERRUPT:
 		if (IS_XFEROUT(transfer) &&
 		    transfer->flags & LIBUSB_TRANSFER_ADD_ZERO_PACKET) {
@@ -506,7 +520,15 @@
 	if (err)
 		return (err);
 
-	usbi_signal_transfer_completion(itransfer);
+	if (transfer->type == LIBUSB_TRANSFER_TYPE_CONTROL) {
+		if (dpriv->devname == NULL)
+			usbi_signal_transfer_completion(itransfer);
+	} else if (transfer->type == LIBUSB_TRANSFER_TYPE_BULK) {
+		if (IS_XFEROUT(transfer))
+			usbi_signal_transfer_completion(itransfer);
+	} else {
+		usbi_signal_transfer_completion(itransfer);
+	}
 
 	return (LIBUSB_SUCCESS);
 }
@@ -528,6 +550,159 @@
 }
 
 int
+obsd_handle_events(struct libusb_context *ctx, struct pollfd *fds, nfds_t nfds,
+    int num_ready)
+{
+	struct libusb_device_handle *handle;
+	struct handle_priv *hpriv = NULL;
+	struct device_priv *dpriv = NULL;
+	struct usbi_transfer *itransfer;
+	struct ctl_urb get_urb;
+	struct pollfd *pollfd;
+	int i, err = 0;
+	int endpt;
+	int error_code = LIBUSB_TRANSFER_COMPLETED;
+	int fd;
+
+	usbi_dbg("");
+
+	pthread_mutex_lock(&ctx->open_devs_lock);
+	for (i = 0; i < nfds && num_ready > 0; i++) {
+		pollfd = &fds[i];
+
+		if (!pollfd->revents)
+			continue;
+
+		hpriv = NULL;
+		num_ready--;
+		list_for_each_entry(handle, &ctx->open_devs, list,
+		    struct libusb_device_handle) {
+			hpriv = (struct handle_priv *)handle->os_priv;
+			dpriv = (struct device_priv *)handle->dev->os_priv;
+
+			if (dpriv->fd == pollfd->fd) {
+				fd = dpriv->fd;
+				break;
+			}
+
+			for (endpt = 0; endpt < USB_MAX_ENDPOINTS; endpt++) {
+				usbi_dbg("is it %d?", hpriv->endpoints[endpt]);
+				if (hpriv->endpoints[endpt] == pollfd->fd) {
+					fd = hpriv->endpoints[endpt];
+					goto out;
+				}
+			}
+
+			hpriv = NULL;
+		}
+
+out:
+		if (NULL == hpriv) {
+			usbi_dbg("fd %d is not an event pipe!", pollfd->fd);
+			err = ENOENT;
+			break;
+		}
+
+		if (pollfd->revents & POLLERR) {
+			usbi_dbg("got a disconnect event");
+			usbi_remove_pollfd(HANDLE_CTX(handle), dpriv->fd);
+			usbi_handle_disconnect(handle);
+			continue;
+		}
+
+		if (fd == dpriv->fd) {
+			while (1) {
+repeat:
+				if (ioctl(dpriv->fd, USB_GET_COMPLETED, &get_urb)) {
+					err = 0;
+					break;
+				}
+				itransfer = get_urb.user_context;
+
+				switch(get_urb.status) {
+				case USBD_NORMAL_COMPLETION:
+				case USBD_SHORT_XFER:
+					usbi_mutex_lock(&itransfer->lock);
+					itransfer->transferred += get_urb.actlen;
+					usbi_dbg("transferred %d", itransfer->transferred);
+					usbi_mutex_unlock(&itransfer->lock);
+
+					error_code = LIBUSB_TRANSFER_COMPLETED;
+					break;
+				case USBD_IN_PROGRESS:
+					goto repeat;
+				/* errors */
+				case USBD_CANCELLED:
+					error_code = LIBUSB_TRANSFER_CANCELLED;
+					break;
+				case USBD_STALLED:
+					error_code = LIBUSB_TRANSFER_STALL;
+					break;
+				default:
+					error_code = LIBUSB_TRANSFER_ERROR;
+					break;
+				}
+				if ((err = usbi_handle_transfer_completion(itransfer, error_code))) {
+					usbi_dbg("error completing");
+					break;
+				}
+			}
+		} else {
+			while (1) {
+rep:
+				if (ioctl(fd, USB_ASYNC_COMPLETE, &get_urb)) {
+					err = 0;
+					break;
+				}
+				itransfer = get_urb.user_context;
+
+				switch(get_urb.status) {
+				case USBD_NORMAL_COMPLETION:
+				case USBD_SHORT_XFER:
+					usbi_mutex_lock(&itransfer->lock);
+					itransfer->transferred += get_urb.actlen;
+					usbi_dbg("transferred %d", itransfer->transferred);
+					usbi_mutex_unlock(&itransfer->lock);
+
+					error_code = LIBUSB_TRANSFER_COMPLETED;
+					break;
+				case USBD_IN_PROGRESS:
+					usbi_dbg("e: in progress");
+					goto rep;
+				/* errors */
+				case USBD_CANCELLED:
+					error_code = LIBUSB_TRANSFER_CANCELLED;
+					usbi_dbg("e: cancelled");
+					break;
+				case USBD_STALLED:
+					error_code = LIBUSB_TRANSFER_STALL;
+					usbi_dbg("e: stall");
+					break;
+				default:
+					error_code = LIBUSB_TRANSFER_ERROR;
+					usbi_dbg("e: some error");
+					break;
+				}
+				if ((err = usbi_handle_transfer_completion(itransfer, error_code))) {
+					usbi_dbg("error completing");
+					break;
+				}
+			}
+		}
+		if (err) {
+			err = errno;
+			break;
+		}
+	}
+	pthread_mutex_unlock(&ctx->open_devs_lock);
+
+	if (err)
+		return _errno_to_libusb(err);
+
+	return (LIBUSB_SUCCESS);
+}
+
+int
 obsd_handle_transfer_completion(struct usbi_transfer *itransfer)
 {
 	return usbi_handle_transfer_completion(itransfer, LIBUSB_TRANSFER_COMPLETED);
@@ -628,6 +803,7 @@
 	struct libusb_control_setup *setup;
 	struct device_priv *dpriv;
 	struct usb_ctl_request req;
+	struct ctl_urb put_urb;
 
 	transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
 	dpriv = (struct device_priv *)transfer->dev_handle->dev->os_priv;
@@ -669,11 +845,20 @@
 		}
 		close(fd);
 	} else {
-		if ((ioctl(dpriv->fd, USB_SET_TIMEOUT, &transfer->timeout)) < 0)
+		put_urb.req = req;
+		put_urb.user_context = itransfer;
+
+		if ((ioctl(dpriv->fd, USB_SET_TIMEOUT, &transfer->timeout)) < 0) {
+			usbi_dbg("fail set timeout");
 			return _errno_to_libusb(errno);
+		}
 
-		if ((ioctl(dpriv->fd, USB_DO_REQUEST, &req)) < 0)
+		if ((ioctl(dpriv->fd, USB_DO_REQUEST, &put_urb)) < 0) {
+			usbi_dbg("fail do request");
 			return _errno_to_libusb(errno);
+		}
+
+		return (0);
 	}
 
 	itransfer->transferred = req.ucr_actlen;
@@ -688,10 +873,12 @@
 {
 	struct handle_priv *hpriv;
 	struct device_priv *dpriv;
+	struct libusb_device_handle *handle;
 	char devnode[16];
 	int fd, endpt;
 	mode_t mode;
 
+	handle = (struct libusb_device_handle *)transfer->dev_handle;
 	hpriv = (struct handle_priv *)transfer->dev_handle->os_priv;
 	dpriv = (struct device_priv *)transfer->dev_handle->dev->os_priv;
 
@@ -705,17 +892,71 @@
 		snprintf(devnode, sizeof(devnode), DEVPATH "%s.%02d",
 		    dpriv->devname, endpt);
 
+		usbi_dbg("devnode %s", devnode);
+
 		/* We may need to read/write to the same endpoint later. */
-		if (((fd = open(devnode, O_RDWR)) < 0) && (errno == ENXIO))
+		if (((fd = open(devnode, O_RDWR)) < 0) && (errno == ENXIO)) {
 			if ((fd = open(devnode, mode)) < 0)
 				return (-1);
+		} else if (fd < 0) {
+			return (-1);
+		}
 
 		hpriv->endpoints[endpt] = fd;
+		usbi_add_pollfd(HANDLE_CTX(handle), fd, POLLIN | POLLRDNORM);
 	}
 
 	return (hpriv->endpoints[endpt]);
 }
 
+int
+_sync_bulk_transfer(struct usbi_transfer *itransfer)
+{
+	struct libusb_transfer *transfer;
+	struct device_priv *dpriv;
+	struct ctl_urb put_urb;
+	int fd, nr = 1;
+
+	usbi_dbg("");
+
+	transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
+	dpriv = (struct device_priv *)transfer->dev_handle->dev->os_priv;
+
+	if (dpriv->devname == NULL)
+		return (LIBUSB_ERROR_NOT_SUPPORTED);
+
+	/*
+	 * Bulk, Interrupt or Isochronous transfer depends on the
+	 * endpoint and thus the node to open.
+	 */
+	if ((fd = _access_endpoint(transfer)) < 0)
+		return _errno_to_libusb(errno);
+
+	if ((ioctl(fd, USB_SET_TIMEOUT, &transfer->timeout)) < 0)
+		return _errno_to_libusb(errno);
+
+	if (IS_XFERIN(transfer)) {
+		if ((transfer->flags & LIBUSB_TRANSFER_SHORT_NOT_OK) == 0)
+			if ((ioctl(fd, USB_SET_SHORT_XFER, &nr)) < 0)
+				return _errno_to_libusb(errno);
+
+		put_urb.read = 1;
+		put_urb.buffer = transfer->buffer;
+		put_urb.actlen = transfer->length;
+		put_urb.user_context = itransfer;
+		if (ioctl(fd, USB_ASYNC_SUBMIT, &put_urb))
+			return _errno_to_libusb(errno);
+	} else {
+		nr = write(fd, transfer->buffer, transfer->length);
+		if (nr < 0)
+			return _errno_to_libusb(errno);
+
+		itransfer->transferred = nr;
+	}
+
+
+	return (0);
+}
 int
 _sync_gen_transfer(struct usbi_transfer *itransfer)
 {
