--- openbsd_usb.c.orig	Wed Jun  3 15:22:32 2015
+++ openbsd_usb.c	Fri Jun  5 14:52:22 2015
@@ -75,6 +75,8 @@
 static int obsd_cancel_transfer(struct usbi_transfer *);
 static void obsd_clear_transfer_priv(struct usbi_transfer *);
 static int obsd_handle_transfer_completion(struct usbi_transfer *);
+static int obsd_handle_events(struct libusb_context *ctx,
+                              struct pollfd *fds, POLL_NFDS_TYPE nfds, int num_ready)
 static int obsd_clock_gettime(int, struct timespec *);
 
 /*
@@ -84,6 +86,7 @@
 static int _cache_active_config_descriptor(struct libusb_device *);
 static int _sync_control_transfer(struct usbi_transfer *);
 static int _sync_gen_transfer(struct usbi_transfer *);
+static int _async_gen_transfer(struct usbi_transfer *);
 static int _access_endpoint(struct libusb_transfer *);
 
 static int _bus_open(int);
@@ -127,7 +130,7 @@
 	obsd_cancel_transfer,
 	obsd_clear_transfer_priv,
 
-	NULL,				/* handle_events() */
+	obsd_handle_events,
 	obsd_handle_transfer_completion,
 
 	obsd_clock_gettime,
@@ -479,7 +482,7 @@
 
 	switch (transfer->type) {
 	case LIBUSB_TRANSFER_TYPE_CONTROL:
-		err = _sync_control_transfer(itransfer);
+		err = _async_control_transfer(itransfer);
 		break;
 	case LIBUSB_TRANSFER_TYPE_ISOCHRONOUS:
 		if (IS_XFEROUT(transfer)) {
@@ -506,9 +509,9 @@
 	if (err)
 		return (err);
 
-	usbi_signal_transfer_completion(itransfer);
+	// usbi_signal_transfer_completion(itransfer);
 
-	return (LIBUSB_SUCCESS);
+	return (LIBUSB_SUCCESS); // does async return success?
 }
 
 int
@@ -534,6 +537,15 @@
 }
 
 int
+obsd_handle_events(struct libusb_context *ctx,
+                   struct pollfd *fds, POLL_NFDS_TYPE nfds, int num_ready)
+{
+	/* fetch completion code and data from completed
+	 * transfer */
+	return 0;
+}
+
+int
 obsd_clock_gettime(int clkid, struct timespec *tp)
 {
 	usbi_dbg("clock %d", clkid);
@@ -684,6 +696,72 @@
 }
 
 int
+_async_control_transfer(struct usbi_transfer *itransfer)
+{
+	struct libusb_transfer *transfer;
+	struct libusb_control_setup *setup;
+	struct device_priv *dpriv;
+	struct usb_ctl_request req;
+
+	transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
+	dpriv = (struct device_priv *)transfer->dev_handle->dev->os_priv;
+	setup = (struct libusb_control_setup *)transfer->buffer;
+
+	usbi_dbg("type %x request %x value %x index %d length %d timeout %d",
+	    setup->bmRequestType, setup->bRequest,
+	    libusb_le16_to_cpu(setup->wValue),
+	    libusb_le16_to_cpu(setup->wIndex),
+	    libusb_le16_to_cpu(setup->wLength), transfer->timeout);
+
+	req.ucr_addr = transfer->dev_handle->dev->device_address;
+	req.ucr_request.bmRequestType = setup->bmRequestType;
+	req.ucr_request.bRequest = setup->bRequest;
+	/* Don't use USETW, libusb already deals with the endianness */
+	(*(uint16_t *)req.ucr_request.wValue) = setup->wValue;
+	(*(uint16_t *)req.ucr_request.wIndex) = setup->wIndex;
+	(*(uint16_t *)req.ucr_request.wLength) = setup->wLength;
+	req.ucr_data = transfer->buffer + LIBUSB_CONTROL_SETUP_SIZE;
+
+	if ((transfer->flags & LIBUSB_TRANSFER_SHORT_NOT_OK) == 0)
+		req.ucr_flags = USBD_SHORT_XFER_OK;
+
+	if (dpriv->devname == NULL) {
+		/*
+		 * XXX If the device is not attached to ugen(4) it is
+		 * XXX still possible to submit a control transfer but
+		 * XXX with the default timeout only.
+		 */
+		int fd, err;
+
+		if ((fd = _bus_open(transfer->dev_handle->dev->bus_number)) < 0)
+			return _errno_to_libusb(errno);
+
+		if ((ioctl(fd, USB_REQUEST, &req)) < 0) {
+			err = errno;
+			close(fd);
+			return _errno_to_libusb(err);
+		}
+		// can we close it if we submitted
+		// asynchronously?
+		close(fd);
+	} else {
+		if ((ioctl(dpriv->fd, USB_SET_TIMEOUT, &transfer->timeout)) < 0)
+			return _errno_to_libusb(errno);
+
+		if ((ioctl(dpriv->fd, USB_DO_REQUEST, &req)) < 0)
+			return _errno_to_libusb(errno);
+	}
+
+	// is this set if it was asynchronous or do we do
+	// this in the callback?
+	itransfer->transferred = req.ucr_actlen;
+
+	usbi_dbg("transferred %d", itransfer->transferred);
+
+	return (0);
+}
+
+int
 _access_endpoint(struct libusb_transfer *transfer)
 {
 	struct handle_priv *hpriv;
@@ -710,10 +788,56 @@
 			if ((fd = open(devnode, mode)) < 0)
 				return (-1);
 
+		fcntl(fd, F_SETFL, O_ASYNC);
+
 		hpriv->endpoints[endpt] = fd;
 	}
 
 	return (hpriv->endpoints[endpt]);
+}
+
+int
+_async_gen_transfer(struct usbi_transfer *itransfer)
+{
+	struct libusb_transfer *transfer;
+	/* struct usb_transfer {
+	 *	int     in;       /* read or write? */
+	 *	void    *buffer;  /* data to be transfered */
+	 *	uint32_t length;  /* length of data */
+	 *	uint16_t flags;   /* flags for usbd */
+	 *};
+	 */
+	struct usb_transfer *t;
+	struct device_priv *dpriv;
+	int fd, nr = 1;
+
+	transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
+	dpriv = (struct device_priv *)transfer->dev_handle->dev->os_priv;
+
+	if (dpriv->devname == NULL)
+		return (LIBUSB_ERROR_NOT_SUPPORTED);
+
+	/*
+	 * Bulk, Interrupt or Isochronous transfer depends on the
+	 * endpoint and thus the node to open.
+	 */
+	if ((fd = _access_endpoint(transfer)) < 0)
+		return _errno_to_libusb(errno);
+
+	if ((ioctl(fd, USB_SET_TIMEOUT, &transfer->timeout)) < 0)
+		return _errno_to_libusb(errno);
+
+	/* DONT CALL READ OR WRITE, use ioctl */
+	t->in = IS_XFERIN(transfer);
+	t->buffer = transfer->buffer;
+	t->length = transfer->length;
+	t->flags = transfer->flags;
+	nr = ioctl(fd, DO_TRANSFER, &t);
+
+	if (nr < 0)
+		return _errno_to_libusb(errno);
+
+	return (0);
 }
 
 int
